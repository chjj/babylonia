{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxFlow","_core","_generator","_default","exports","default","declare","api","assertVersion","commentFromString","comment","type","value","attachComment","ofPath","toPath","where","optional","comments","generateComment","keepType","_toPath","node","getPrevSibling","getNextSibling","parentPath","Array","isArray","newComments","map","parent","prev","next","isSingleChild","leading","leadingComments","trailing","trailingComments","addComments","remove","wrapInFlowComment","path","getSource","replace","isTypeImport","importKind","name","inherits","syntaxFlow","visitor","TypeCastExpression","get","replaceWith","t","parenthesizedExpression","expression","Identifier","isFlow","typeAnnotation","AssignmentPattern","exit","left","Function","isDeclareFunction","typeParameters","returnType","ClassProperty","ExportNamedDeclaration","exportKind","declaration","ImportDeclaration","typeSpecifiers","specifiers","filter","specifier","nonTypeSpecifiers","length","typeImportNode","cloneNode","generateCode","code","ObjectPattern","Flow","Class","push","superClass","superTypeParameters","implements","impls","impl","join"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxFlow from \"@babel/plugin-syntax-flow\";\nimport { types as t } from \"@babel/core\";\nimport generateCode from \"@babel/generator\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport default declare(api => {\n  api.assertVersion(\n    process.env.BABEL_8_BREAKING && process.env.IS_PUBLISH\n      ? PACKAGE_JSON.version\n      : 7,\n  );\n\n  function commentFromString(comment: string | t.Comment): t.Comment {\n    return typeof comment === \"string\"\n      ? { type: \"CommentBlock\", value: comment }\n      : comment;\n  }\n\n  function attachComment({\n    ofPath,\n    toPath,\n    where = \"trailing\",\n    optional = false,\n    comments = generateComment(ofPath, optional),\n    keepType = false,\n  }: {\n    ofPath?: NodePath;\n    toPath?: NodePath;\n    where?: t.CommentTypeShorthand;\n    optional?: boolean;\n    comments?: string | t.Comment | (string | t.Comment)[];\n    keepType?: boolean;\n  }) {\n    if (!toPath?.node) {\n      toPath = ofPath.getPrevSibling();\n      where = \"trailing\";\n    }\n    if (!toPath.node) {\n      toPath = ofPath.getNextSibling();\n      where = \"leading\";\n    }\n    if (!toPath.node) {\n      toPath = ofPath.parentPath;\n      where = \"inner\";\n    }\n    if (!Array.isArray(comments)) {\n      comments = [comments];\n    }\n    const newComments = comments.map(commentFromString);\n    if (!keepType && ofPath?.node) {\n      // Removes the node at `ofPath` while conserving the comments attached\n      // to it.\n      const node = ofPath.node;\n      const parent = ofPath.parentPath;\n      const prev = ofPath.getPrevSibling();\n      const next = ofPath.getNextSibling();\n      const isSingleChild = !(prev.node || next.node);\n      const leading = node.leadingComments;\n      const trailing = node.trailingComments;\n\n      if (isSingleChild && leading) {\n        parent.addComments(\"inner\", leading);\n      }\n      toPath.addComments(where, newComments);\n      ofPath.remove();\n      if (isSingleChild && trailing) {\n        parent.addComments(\"inner\", trailing);\n      }\n    } else {\n      toPath.addComments(where, newComments);\n    }\n  }\n\n  function wrapInFlowComment<\n    N extends\n      | t.ClassProperty\n      | t.ExportNamedDeclaration\n      | t.Flow\n      | t.ImportDeclaration\n      | t.ExportDeclaration\n      | t.ImportSpecifier\n      | t.ImportDeclaration,\n  >(path: NodePath<N>) {\n    attachComment({\n      ofPath: path,\n      // @ts-expect-error optional may not exist in path.parent\n      comments: generateComment(path, path.parent.optional),\n    });\n  }\n\n  function generateComment(path: NodePath, optional?: boolean | void) {\n    let comment = path\n      .getSource()\n      .replace(/\\*-\\//g, \"*-ESCAPED/\")\n      .replace(/\\*\\//g, \"*-/\");\n    if (optional) comment = \"?\" + comment;\n    if (comment[0] !== \":\") comment = \":: \" + comment;\n    return comment;\n  }\n\n  function isTypeImport(importKind: \"type\" | \"typeof\" | \"value\") {\n    return importKind === \"type\" || importKind === \"typeof\";\n  }\n\n  return {\n    name: \"transform-flow-comments\",\n    inherits: syntaxFlow,\n\n    visitor: {\n      TypeCastExpression(path) {\n        const { node } = path;\n        attachComment({\n          ofPath: path.get(\"typeAnnotation\"),\n          toPath: path.get(\"expression\"),\n          keepType: true,\n        });\n        path.replaceWith(t.parenthesizedExpression(node.expression));\n      },\n\n      // support function a(b?) {}\n      Identifier(path) {\n        if (path.parentPath.isFlow()) return;\n        const { node } = path;\n        if (node.typeAnnotation) {\n          attachComment({\n            ofPath: path.get(\"typeAnnotation\"),\n            toPath: path,\n            optional:\n              node.optional ||\n              // @ts-expect-error Fixme: optional is not in t.TypeAnnotation,\n              // maybe we can remove it\n              node.typeAnnotation.optional,\n          });\n          if (node.optional) {\n            node.optional = false;\n          }\n        } else if (node.optional) {\n          attachComment({\n            toPath: path,\n            comments: \":: ?\",\n          });\n          node.optional = false;\n        }\n      },\n\n      AssignmentPattern: {\n        exit({ node }) {\n          const { left } = node;\n          // @ts-expect-error optional is not in TSAsExpression\n          if (left.optional) {\n            // @ts-expect-error optional is not in TSAsExpression\n            left.optional = false;\n          }\n        },\n      },\n\n      // strip optional property from function params - facebook/fbjs#17\n      Function(path) {\n        if (path.isDeclareFunction()) return;\n        const { node } = path;\n        if (node.typeParameters) {\n          attachComment({\n            ofPath: path.get(\"typeParameters\"),\n            toPath: path.get(\"id\"),\n            // @ts-expect-error Fixme: optional is not in t.TypeParameterDeclaration\n            optional: node.typeParameters.optional,\n          });\n        }\n        if (node.returnType) {\n          attachComment({\n            ofPath: path.get(\"returnType\"),\n            toPath: path.get(\"body\"),\n            where: \"leading\",\n            // @ts-expect-error Fixme: optional is not in t.TypeAnnotation\n            optional: node.returnType.typeAnnotation.optional,\n          });\n        }\n      },\n\n      // support for `class X { foo: string }` - #4622\n      ClassProperty(path) {\n        const { node } = path;\n        if (!node.value) {\n          wrapInFlowComment(path);\n        } else if (node.typeAnnotation) {\n          attachComment({\n            ofPath: path.get(\"typeAnnotation\"),\n            toPath: path.get(\"key\"),\n            // @ts-expect-error Fixme: optional is not in t.TypeAnnotation\n            optional: node.typeAnnotation.optional,\n          });\n        }\n      },\n\n      // support `export type a = {}` - #8 Error: You passed path.replaceWith() a falsy node\n      ExportNamedDeclaration(path) {\n        const { node } = path;\n        if (node.exportKind !== \"type\" && !t.isFlow(node.declaration)) {\n          return;\n        }\n        wrapInFlowComment(path);\n      },\n\n      // support `import type A` and `import typeof A` #10\n      ImportDeclaration(path) {\n        const { node } = path;\n        if (isTypeImport(node.importKind)) {\n          wrapInFlowComment(path);\n          return;\n        }\n\n        const typeSpecifiers = node.specifiers.filter(\n          specifier =>\n            specifier.type === \"ImportSpecifier\" &&\n            isTypeImport(specifier.importKind),\n        );\n\n        const nonTypeSpecifiers = node.specifiers.filter(\n          specifier =>\n            specifier.type !== \"ImportSpecifier\" ||\n            !isTypeImport(specifier.importKind),\n        );\n        node.specifiers = nonTypeSpecifiers;\n\n        if (typeSpecifiers.length > 0) {\n          const typeImportNode = t.cloneNode(node);\n          typeImportNode.specifiers = typeSpecifiers;\n          const comment = `:: ${generateCode(typeImportNode).code}`;\n\n          if (nonTypeSpecifiers.length > 0) {\n            attachComment({ toPath: path, comments: comment });\n          } else {\n            attachComment({ ofPath: path, comments: comment });\n          }\n        }\n      },\n      ObjectPattern(path) {\n        const { node } = path;\n        if (node.typeAnnotation) {\n          attachComment({\n            ofPath: path.get(\"typeAnnotation\"),\n            toPath: path,\n            optional:\n              node.optional ||\n              // @ts-expect-error Fixme: optional is not in t.TypeAnnotation\n              node.typeAnnotation.optional,\n          });\n        }\n      },\n\n      Flow(\n        path: NodePath<\n          t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier\n        >,\n      ) {\n        wrapInFlowComment(path);\n      },\n\n      Class(path) {\n        const { node } = path;\n        let comments: [string?, ...(string | t.Comment)[]] = [];\n        if (node.typeParameters) {\n          const typeParameters = path.get(\"typeParameters\");\n          comments.push(\n            // @ts-expect-error optional is not in TypeParameterDeclaration\n            generateComment(typeParameters, node.typeParameters.optional),\n          );\n          const trailingComments = node.typeParameters.trailingComments;\n          if (trailingComments) {\n            comments.push(...trailingComments);\n          }\n          typeParameters.remove();\n        }\n\n        if (node.superClass) {\n          if (comments.length > 0) {\n            attachComment({\n              toPath: path.get(\"id\"),\n              comments: comments,\n            });\n            comments = [];\n          }\n\n          if (node.superTypeParameters) {\n            const superTypeParameters = path.get(\n              \"superTypeParameters\",\n            ) as NodePath<t.TypeParameterInstantiation>;\n            comments.push(\n              generateComment(\n                superTypeParameters,\n                // @ts-expect-error optional is not in TypeParameterInstantiation\n                superTypeParameters.node.optional,\n              ),\n            );\n            superTypeParameters.remove();\n          }\n        }\n\n        if (node.implements) {\n          const impls = path.get(\"implements\");\n          const comment =\n            \"implements \" +\n            impls\n              .map(impl => generateComment(impl).replace(/^:: /, \"\"))\n              .join(\", \");\n          delete node[\"implements\"];\n\n          if (comments.length === 1) {\n            comments[0] += ` ${comment}`;\n          } else {\n            comments.push(`:: ${comment}`);\n          }\n        }\n\n        if (comments.length > 0) {\n          attachComment({\n            toPath: path.get(\"body\"),\n            where: \"leading\",\n            comments: comments,\n          });\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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"}