{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxAsyncDoExpressions","_helperHoistVariables","_default","exports","default","declare","types","t","assertVersion","name","inherits","syntaxAsyncDoExpressions","visitor","DoExpression","exit","path","is","scope","hoistVariables","id","push","cloneNode","bodyPath","get","completionRecords","getCompletionRecords","p","isExpressionStatement","replaceWith","returnStatement","node","expression","callExpression","arrowFunctionExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxAsyncDoExpressions from \"@babel/plugin-syntax-async-do-expressions\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\nimport type * as t from \"@babel/types\";\n\nexport default declare(({ types: t, assertVersion }) => {\n  assertVersion(\n    process.env.BABEL_8_BREAKING && process.env.IS_PUBLISH\n      ? PACKAGE_JSON.version\n      : \"^7.13.0\",\n  );\n\n  return {\n    name: \"proposal-async-do-expressions\",\n    inherits: syntaxAsyncDoExpressions,\n    visitor: {\n      DoExpression: {\n        exit(path) {\n          if (!path.is(\"async\")) {\n            // non-async do expressions are handled by proposal-do-expressions\n            return;\n          }\n          const { scope } = path;\n          // Hoist variable declaration to containing function scope\n          // `async do { var x = 1; x }` -> `var x; (async() => { x = 1; return x })()`\n          hoistVariables(\n            path,\n            (id: t.Identifier) => {\n              scope.push({ id: t.cloneNode(id) });\n            },\n            \"var\",\n          );\n          const bodyPath = path.get(\"body\");\n\n          // add implicit returns to all ending expression statements\n          const completionRecords = bodyPath.getCompletionRecords();\n\n          for (const p of completionRecords) {\n            if (p.isExpressionStatement()) {\n              p.replaceWith(t.returnStatement(p.node.expression));\n            }\n          }\n\n          path.replaceWith(\n            t.callExpression(\n              t.arrowFunctionExpression([], bodyPath.node, /* async */ true),\n              [],\n            ),\n          );\n        },\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,+BAAA,GAAAD,OAAA;AACA,IAAAE,qBAAA,GAAAF,OAAA;AAA2D,IAAAG,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAG5C,IAAAC,0BAAO,EAAC,CAAC;EAAEC,KAAK,EAAEC,CAAC;EAAEC;AAAc,CAAC,KAAK;EACtDA,aAAa,CAGP,SACN,CAAC;EAED,OAAO;IACLC,IAAI,EAAE,+BAA+B;IACrCC,QAAQ,EAAEC,uCAAwB;IAClCC,OAAO,EAAE;MACPC,YAAY,EAAE;QACZC,IAAIA,CAACC,IAAI,EAAE;UACT,IAAI,CAACA,IAAI,CAACC,EAAE,CAAC,OAAO,CAAC,EAAE;YAErB;UACF;UACA,MAAM;YAAEC;UAAM,CAAC,GAAGF,IAAI;UAGtB,IAAAG,6BAAc,EACZH,IAAI,EACHI,EAAgB,IAAK;YACpBF,KAAK,CAACG,IAAI,CAAC;cAAED,EAAE,EAAEZ,CAAC,CAACc,SAAS,CAACF,EAAE;YAAE,CAAC,CAAC;UACrC,CAAC,EACD,KACF,CAAC;UACD,MAAMG,QAAQ,GAAGP,IAAI,CAACQ,GAAG,CAAC,MAAM,CAAC;UAGjC,MAAMC,iBAAiB,GAAGF,QAAQ,CAACG,oBAAoB,CAAC,CAAC;UAEzD,KAAK,MAAMC,CAAC,IAAIF,iBAAiB,EAAE;YACjC,IAAIE,CAAC,CAACC,qBAAqB,CAAC,CAAC,EAAE;cAC7BD,CAAC,CAACE,WAAW,CAACrB,CAAC,CAACsB,eAAe,CAACH,CAAC,CAACI,IAAI,CAACC,UAAU,CAAC,CAAC;YACrD;UACF;UAEAhB,IAAI,CAACa,WAAW,CACdrB,CAAC,CAACyB,cAAc,CACdzB,CAAC,CAAC0B,uBAAuB,CAAC,EAAE,EAAEX,QAAQ,CAACQ,IAAI,EAAc,IAAI,CAAC,EAC9D,EACF,CACF,CAAC;QACH;MACF;IACF;EACF,CAAC;AACH,CAAC,CAAC"}