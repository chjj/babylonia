{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type * as t from \"@babel/types\";\nimport type { Scope } from \"@babel/traverse\";\nimport { types } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport { buildObjectExcludingKeys } from \"@babel/plugin-transform-destructuring\";\nconst {\n  assignmentExpression,\n  binaryExpression,\n  conditionalExpression,\n  cloneNode,\n  isObjectProperty,\n  isPrivateName,\n  memberExpression,\n  numericLiteral,\n  objectPattern,\n  restElement,\n  variableDeclarator,\n  variableDeclaration,\n  unaryExpression,\n} = types;\n\nfunction buildUndefinedNode() {\n  return unaryExpression(\"void\", numericLiteral(0));\n}\n\nfunction transformAssignmentPattern(\n  initializer: t.Expression,\n  tempId: t.Identifier,\n) {\n  return conditionalExpression(\n    binaryExpression(\"===\", cloneNode(tempId), buildUndefinedNode()),\n    initializer,\n    cloneNode(tempId),\n  );\n}\n\nfunction initRestExcludingKeys(pattern: t.LVal): ExcludingKey[] | null {\n  if (pattern.type === \"ObjectPattern\") {\n    const { properties } = pattern;\n    if (properties[properties.length - 1].type === \"RestElement\") {\n      return [];\n    }\n  }\n  return null;\n}\n\n/**\n * grow `excludingKeys` from given properties. This routine mutates properties by\n * memoising the computed non-static keys.\n *\n * @param {ExcludingKey[]} excludingKeys\n * @param {t.ObjectProperty[]} properties An array of object properties that should be excluded by rest element transform\n * @param {Scope} scope Where should we register the memoised id\n */\nfunction growRestExcludingKeys(\n  excludingKeys: ExcludingKey[],\n  properties: t.ObjectProperty[],\n  scope: Scope,\n) {\n  if (excludingKeys === null) return;\n  for (const property of properties) {\n    const propertyKey = property.key;\n    if (property.computed && !scope.isStatic(propertyKey)) {\n      const tempId = scope.generateDeclaredUidIdentifier(\"m\");\n      // @ts-expect-error A computed property key must not be a private name\n      property.key = assignmentExpression(\"=\", tempId, propertyKey);\n      excludingKeys.push({ key: tempId, computed: true });\n    } else if (propertyKey.type !== \"PrivateName\") {\n      excludingKeys.push(property);\n    }\n  }\n}\n\n/**\n * Prepare var declarations for params. Only param initializers\n * will be transformed to undefined coalescing, other features are preserved.\n * This function does NOT mutate given AST structures.\n *\n * @export\n * @param {Function[\"params\"]} params An array of function params\n * @param {Scope} scope A scope used to generate uid for function params\n * @returns {{ params: Identifier[]; variableDeclaration: VariableDeclaration }} An array of new id for params\n * and variable declaration to be prepended to the function body\n */\nexport function buildVariableDeclarationFromParams(\n  params: t.Function[\"params\"],\n  scope: Scope,\n): {\n  params: (t.Identifier | t.RestElement)[];\n  variableDeclaration: t.VariableDeclaration;\n} {\n  const { elements, transformed } = buildAssignmentsFromPatternList(\n    params,\n    scope,\n    /* isAssignment */ false,\n  );\n  return {\n    params: elements,\n    variableDeclaration: variableDeclaration(\n      \"var\",\n      transformed.map(({ left, right }) => variableDeclarator(left, right)),\n    ),\n  };\n}\n\ninterface Transformed {\n  left: Exclude<LHS, t.AssignmentPattern>;\n  right: t.Expression;\n}\n\nfunction buildAssignmentsFromPatternList(\n  elements: (t.LVal | null)[],\n  scope: Scope,\n  isAssignment: boolean,\n): {\n  elements: (t.Identifier | t.RestElement | null)[];\n  transformed: Transformed[];\n} {\n  const newElements: (t.Identifier | t.RestElement)[] = [],\n    transformed: Transformed[] = [];\n  for (let element of elements) {\n    if (element === null) {\n      newElements.push(null);\n      transformed.push(null);\n      continue;\n    }\n    const tempId = scope.generateUidIdentifier(\"p\");\n    if (isAssignment) {\n      scope.push({ id: cloneNode(tempId) });\n    }\n    if (element.type === \"RestElement\") {\n      newElements.push(restElement(tempId));\n      // The argument of a RestElement within a BindingPattern must be either Identifier or BindingPattern\n      element = element.argument as t.Identifier | t.Pattern;\n    } else {\n      newElements.push(tempId);\n    }\n    if (element.type === \"AssignmentPattern\") {\n      transformed.push({\n        left: element.left,\n        right: transformAssignmentPattern(element.right, tempId),\n      });\n    } else {\n      transformed.push({\n        left: element as Transformed[\"left\"],\n        right: cloneNode(tempId),\n      });\n    }\n  }\n  return { elements: newElements, transformed };\n}\n\ntype StackItem = {\n  node: t.AssignmentExpression[\"left\"] | t.ObjectProperty | null;\n  index: number;\n  depth: number;\n};\n\n/**\n * A DFS simplified pattern traverser. It skips computed property keys and assignment pattern\n * initializers. The following nodes will be delegated to the visitor:\n * - ArrayPattern\n * - ArrayPattern elements\n * - AssignmentPattern\n * - ObjectPattern\n * - ObjectProperty\n * - RestElement\n * @param root\n * @param visitor\n */\nexport function* traversePattern(\n  root: t.AssignmentExpression[\"left\"],\n  visitor: (\n    node: t.AssignmentExpression[\"left\"] | t.ObjectProperty,\n    index: number,\n    depth: number,\n  ) => Generator<any, void, any>,\n) {\n  const stack: StackItem[] = [];\n  stack.push({ node: root, index: 0, depth: 0 });\n  let item: StackItem;\n  while ((item = stack.pop()) !== undefined) {\n    const { node, index } = item;\n    if (node === null) continue;\n    yield* visitor(node, index, item.depth);\n    const depth = item.depth + 1;\n    switch (node.type) {\n      case \"AssignmentPattern\":\n        stack.push({ node: node.left, index: 0, depth });\n        break;\n      case \"ObjectProperty\":\n        // inherit the depth and index as an object property can not be an LHS without object pattern\n        stack.push({ node: node.value as t.LVal, index, depth: item.depth });\n        break;\n      case \"RestElement\":\n        stack.push({ node: node.argument, index: 0, depth });\n        break;\n      case \"ObjectPattern\":\n        for (let list = node.properties, i = list.length - 1; i >= 0; i--) {\n          stack.push({ node: list[i], index: i, depth });\n        }\n        break;\n      case \"ArrayPattern\":\n        for (let list = node.elements, i = list.length - 1; i >= 0; i--) {\n          stack.push({ node: list[i], index: i, depth });\n        }\n        break;\n      case \"TSParameterProperty\":\n      case \"TSAsExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        throw new Error(\n          `TypeScript features must first be transformed by ` +\n            `@babel/plugin-transform-typescript.\\n` +\n            `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` +\n            `that it runs before @babel/plugin-proposal-destructuring-private.`,\n        );\n      default:\n        break;\n    }\n  }\n}\n\nexport function hasPrivateKeys(pattern: t.AssignmentExpression[\"left\"]) {\n  let result = false;\n  traversePattern(pattern, function* (node) {\n    if (isObjectProperty(node) && isPrivateName(node.key)) {\n      result = true;\n      // stop the traversal\n      yield;\n    }\n  }).next();\n  return result;\n}\n\nexport function hasPrivateClassElement(node: t.ClassBody): boolean {\n  return node.body.some(element =>\n    isPrivateName(\n      // @ts-expect-error: for those class element without `key`, they must\n      // not be a private element\n      element.key,\n    ),\n  );\n}\n\n/**\n * Traverse the given pattern and report the private key path.\n * A private key path is analogous to an array of `key` from the pattern NodePath\n * to the private key NodePath. See also test/util.skip-bundled.js for an example output\n *\n * @export\n * @param {t.LVal} pattern\n */\nexport function* privateKeyPathIterator(pattern: t.LVal) {\n  const indexPath: number[] = [];\n  yield* traversePattern(pattern, function* (node, index, depth) {\n    indexPath[depth] = index;\n    if (isObjectProperty(node) && isPrivateName(node.key)) {\n      // The indexPath[0, depth] contains the path from root pattern to the object property\n      // with private key. The indexPath may have more than depth + 1 elements because we\n      // don't shrink the indexPath when the traverser returns to parent nodes.\n      yield indexPath.slice(1, depth + 1);\n    }\n  });\n}\n\ntype LHS = Exclude<t.LVal, t.RestElement | t.TSParameterProperty>;\n\ntype ExcludingKey = {\n  key: t.ObjectProperty[\"key\"];\n  computed: t.ObjectProperty[\"computed\"];\n};\ntype Item = {\n  left: LHS;\n  right: t.Expression;\n  restExcludingKeys?: ExcludingKey[] | null;\n};\n\nfunction rightWillBeReferencedOnce(left: LHS) {\n  switch (left.type) {\n    // Skip memoising the right when left is an identifier or\n    // an array pattern\n    case \"Identifier\":\n    case \"ArrayPattern\":\n      return true;\n    case \"ObjectPattern\":\n      return left.properties.length === 1;\n    default:\n      return false;\n  }\n}\n/**\n * Transform private destructuring. It returns a generator\n * which yields a pair of transformed LHS and RHS, which can form VariableDeclaration or\n * AssignmentExpression later.\n *\n * @export\n * @param {LHS} left The root pattern\n * @param {t.Expression} right The initializer or the RHS of pattern\n * @param {Scope} scope The scope where memoized id should be registered\n * @param {boolean} isAssignment Whether we are transforming from an AssignmentExpression of VariableDeclaration\n * @returns {Generator<Transformed, void, void>}\n */\nexport function* transformPrivateKeyDestructuring(\n  left: LHS,\n  right: t.Expression,\n  scope: Scope,\n  isAssignment: boolean,\n  shouldPreserveCompletion: boolean,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): Generator<Transformed, void, void> {\n  const stack: Item[] = [];\n  const rootRight = right;\n  // The stack holds patterns that we don't known whether they contain private key\n  stack.push({\n    left,\n    right,\n    restExcludingKeys: initRestExcludingKeys(left),\n  });\n  let item: Item;\n  while ((item = stack.pop()) !== undefined) {\n    const { restExcludingKeys } = item;\n    let { left, right } = item;\n    const searchPrivateKey = privateKeyPathIterator(left).next();\n    if (searchPrivateKey.done) {\n      if (restExcludingKeys?.length > 0) {\n        // optimize out the rest element because `objectWithoutProperties`\n        // returns a new object\n        // `{ ...z } = babelHelpers.objectWithoutProperties(m, [\"x\"])`\n        // to\n        // `z = babelHelpers.objectWithoutProperties(m, [\"x\"])`\n        const { properties } = left as t.ObjectPattern;\n        if (properties.length === 1) {\n          // The argument of an object rest element must be an Identifier\n          left = (properties[0] as t.RestElement).argument as t.Identifier;\n        }\n        yield {\n          left: left as t.ObjectPattern,\n          right: buildObjectExcludingKeys(\n            restExcludingKeys,\n            right,\n            scope,\n            addHelper,\n            objectRestNoSymbols,\n            useBuiltIns,\n          ),\n        };\n      } else {\n        yield {\n          left:\n            // An assignment pattern will not be pushed to the stack\n            left as Transformed[\"left\"],\n          right,\n        };\n      }\n    } else {\n      // now we need to split according to the indexPath;\n      const indexPath = searchPrivateKey.value;\n      for (\n        let indexPathIndex = 0, index;\n        (indexPathIndex < indexPath.length &&\n          (index = indexPath[indexPathIndex]) !== undefined) ||\n        left.type === \"AssignmentPattern\";\n        indexPathIndex++\n      ) {\n        const isRightSafeToReuse =\n          // If we should preserve completion and the right is the rootRight, then the\n          // right is NOT safe to reuse because we will insert a new memoising statement\n          // in the AssignmentExpression visitor, which causes right to be referenced more\n          // than once\n          !(shouldPreserveCompletion && right === rootRight) &&\n          (rightWillBeReferencedOnce(left) || scope.isStatic(right));\n        if (!isRightSafeToReuse) {\n          const tempId = scope.generateUidIdentifier(\"m\");\n          if (isAssignment) {\n            scope.push({ id: cloneNode(tempId) });\n          }\n          yield { left: tempId, right };\n          right = cloneNode(tempId);\n        }\n        // invariant: at this point right must be a static identifier;\n        switch (left.type) {\n          case \"ObjectPattern\": {\n            const { properties } = left;\n            if (index > 0) {\n              // properties[0, index) must not contain private keys\n              const propertiesSlice = properties.slice(0, index);\n              yield {\n                left: objectPattern(propertiesSlice),\n                right: cloneNode(right),\n              };\n            }\n            if (index < properties.length - 1) {\n              // for properties after `index`, push them to stack so we can process them later\n              // inherit the restExcludingKeys on the stack if we are at\n              // the first level, otherwise initialize a new restExcludingKeys\n              const nextRestExcludingKeys =\n                indexPathIndex === 0\n                  ? restExcludingKeys\n                  : initRestExcludingKeys(left);\n              growRestExcludingKeys(\n                nextRestExcludingKeys,\n                // @ts-expect-error properties[0, index] must not contain rest element\n                // because properties[index] contains a private key\n                properties.slice(0, index + 1),\n                scope,\n              );\n              stack.push({\n                left: objectPattern(properties.slice(index + 1)),\n                right: cloneNode(right),\n                restExcludingKeys: nextRestExcludingKeys,\n              });\n            }\n            // An object rest element must not contain a private key\n            const property = properties[index] as t.ObjectProperty;\n            // The value of ObjectProperty under ObjectPattern must be an LHS\n            left = property.value as LHS;\n            const { key } = property;\n            const computed =\n              property.computed ||\n              // `{ 0: x } = RHS` is transformed to a computed member expression `x = RHS[0]`\n              (key.type !== \"Identifier\" && key.type !== \"PrivateName\");\n            right = memberExpression(right, key, computed);\n            break;\n          }\n          case \"AssignmentPattern\": {\n            right = transformAssignmentPattern(\n              left.right,\n              right as t.Identifier,\n            );\n            left = left.left;\n            break;\n          }\n          case \"ArrayPattern\": {\n            // todo: the transform here assumes that any expression within\n            // the array pattern, when evaluated, do not interfere with the iterable\n            // in RHS. Otherwise we have to pause the iterable and interleave\n            // the expressions.\n            // See also https://gist.github.com/nicolo-ribaudo/f8ac7916f89450f2ead77d99855b2098\n            // and ordering/array-pattern-side-effect-iterable test\n            const leftElements = left.elements;\n            const leftElementsAfterIndex = leftElements.splice(index);\n            const { elements, transformed } = buildAssignmentsFromPatternList(\n              leftElementsAfterIndex,\n              scope,\n              isAssignment,\n            );\n            leftElements.push(...elements);\n            yield { left, right: cloneNode(right) };\n            // for elements after `index`, push them to stack so we can process them later\n            for (let i = transformed.length - 1; i > 0; i--) {\n              // skipping array holes\n              if (transformed[i] !== null) {\n                stack.push(transformed[i]);\n              }\n            }\n            ({ left, right } = transformed[0]);\n            break;\n          }\n          default:\n            break;\n        }\n      }\n      stack.push({\n        left,\n        right,\n        restExcludingKeys: initRestExcludingKeys(left),\n      });\n    }\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxDestructuringPrivate from \"@babel/plugin-syntax-destructuring-private\";\nimport {\n  hasPrivateKeys,\n  hasPrivateClassElement,\n  transformPrivateKeyDestructuring,\n  buildVariableDeclarationFromParams,\n} from \"./util.ts\";\nimport { convertFunctionParams } from \"@babel/plugin-transform-parameters\";\nimport { unshiftForXStatementBody } from \"@babel/plugin-transform-destructuring\";\n\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport default declare(function ({ assertVersion, assumption, types: t }) {\n  assertVersion(\n    process.env.BABEL_8_BREAKING && process.env.IS_PUBLISH\n      ? PACKAGE_JSON.version\n      : \"^7.17.0\",\n  );\n  const {\n    assignmentExpression,\n    assignmentPattern,\n    cloneNode,\n    expressionStatement,\n    isExpressionStatement,\n    isIdentifier,\n    isSequenceExpression,\n    sequenceExpression,\n    variableDeclaration,\n    variableDeclarator,\n  } = t;\n\n  const ignoreFunctionLength = assumption(\"ignoreFunctionLength\");\n  const objectRestNoSymbols = assumption(\"objectRestNoSymbols\");\n\n  const privateKeyDestructuringVisitor: Visitor<PluginPass> = {\n    Function(path) {\n      // (b, { #x: x } = I) => body\n      // transforms to:\n      // (b, p1) => { var { #x: x } = p1 === undefined ? I : p1; body; }\n      const firstPrivateIndex = path.node.params.findIndex(param =>\n        hasPrivateKeys(param),\n      );\n      if (firstPrivateIndex === -1) return;\n      // wrap function body within IIFE if any param is shadowed\n      convertFunctionParams(path, ignoreFunctionLength, () => false);\n      // invariant: path.body is always a BlockStatement after `convertFunctionParams`\n      const { node, scope } = path;\n      const { params } = node;\n      const firstAssignmentPatternIndex = ignoreFunctionLength\n        ? -1\n        : params.findIndex(param => param.type === \"AssignmentPattern\");\n      const paramsAfterIndex = params.splice(firstPrivateIndex);\n      const { params: transformedParams, variableDeclaration } =\n        buildVariableDeclarationFromParams(paramsAfterIndex, scope);\n\n      (path.get(\"body\") as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        variableDeclaration,\n      );\n      params.push(...transformedParams);\n      // preserve function.length\n      // (b, p1) => {}\n      // transforms to\n      // (b, p1 = void 0) => {}\n      if (firstAssignmentPatternIndex >= firstPrivateIndex) {\n        params[firstAssignmentPatternIndex] = assignmentPattern(\n          // @ts-expect-error The transformed assignment pattern must not be a RestElement\n          params[firstAssignmentPatternIndex],\n          scope.buildUndefinedNode(),\n        );\n      }\n      scope.crawl();\n      // the pattern will be handled by VariableDeclaration visitor.\n    },\n    CatchClause(path) {\n      // catch({ #x: x }) { body }\n      // transforms to:\n      // catch(_e) { var {#x: x } = _e; body }\n      const { node, scope } = path;\n      if (!hasPrivateKeys(node.param)) return;\n      // todo: handle shadowed param as we did in convertFunctionParams\n      const ref = scope.generateUidIdentifier(\"e\");\n      path\n        .get(\"body\")\n        .unshiftContainer(\n          \"body\",\n          variableDeclaration(\"let\", [variableDeclarator(node.param, ref)]),\n        );\n      node.param = cloneNode(ref);\n      scope.crawl();\n      // the pattern will be handled by VariableDeclaration visitor.\n    },\n    ForXStatement(path) {\n      const { node, scope } = path;\n      const leftPath = path.get(\"left\");\n      if (leftPath.isVariableDeclaration()) {\n        const left = leftPath.node;\n        if (!hasPrivateKeys(left.declarations[0].id)) return;\n        // for (const { #x: x } of cls) body;\n        // transforms to:\n        // for (const ref of cls) { const { #x: x } = ref; body; }\n        // todo: the transform here assumes that any expression within\n        // the destructuring pattern (`{ #x: x }`), when evaluated, do not interfere\n        // with the iterator of cls. Otherwise we have to pause the iterator and\n        // interleave the expressions.\n        // See also https://gist.github.com/nicolo-ribaudo/f8ac7916f89450f2ead77d99855b2098\n        const temp = scope.generateUidIdentifier(\"ref\");\n        node.left = variableDeclaration(left.kind, [\n          variableDeclarator(temp, null),\n        ]);\n        left.declarations[0].init = cloneNode(temp);\n        unshiftForXStatementBody(path, [left]);\n        scope.crawl();\n        // the pattern will be handled by VariableDeclaration visitor.\n      } else if (leftPath.isPattern()) {\n        if (!hasPrivateKeys(leftPath.node)) return;\n        // for ({ #x: x } of cls);\n        // transforms to:\n        // for (const ref of cls) { ({ #x: x } = ref); body; }\n        // This transform assumes that any expression within the pattern\n        // does not interfere with the iterable `cls`.\n        const temp = scope.generateUidIdentifier(\"ref\");\n        node.left = variableDeclaration(\"const\", [\n          variableDeclarator(temp, null),\n        ]);\n        const assignExpr = expressionStatement(\n          assignmentExpression(\"=\", leftPath.node, cloneNode(temp)),\n        );\n        unshiftForXStatementBody(path, [assignExpr]);\n        scope.crawl();\n      }\n    },\n    VariableDeclaration(path, state) {\n      const { scope, node } = path;\n      const { declarations } = node;\n      if (!declarations.some(declarator => hasPrivateKeys(declarator.id))) {\n        return;\n      }\n      const newDeclarations = [];\n      for (const declarator of declarations) {\n        for (const { left, right } of transformPrivateKeyDestructuring(\n          // @ts-expect-error The id of a variable declarator must not be a RestElement\n          declarator.id,\n          declarator.init,\n          scope,\n          /* isAssignment */ false,\n          /* shouldPreserveCompletion */ false,\n          name => state.addHelper(name),\n          objectRestNoSymbols,\n          /* useBuiltIns */ true,\n        )) {\n          newDeclarations.push(variableDeclarator(left, right));\n        }\n      }\n      node.declarations = newDeclarations;\n      scope.crawl();\n    },\n\n    AssignmentExpression(path, state) {\n      const { node, scope, parent } = path;\n      if (!hasPrivateKeys(node.left)) return;\n      const assignments = [];\n      const shouldPreserveCompletion =\n        (!isExpressionStatement(parent) && !isSequenceExpression(parent)) ||\n        path.isCompletionRecord();\n      for (const { left, right } of transformPrivateKeyDestructuring(\n        // @ts-expect-error The left of an assignment expression must not be a RestElement\n        node.left,\n        node.right,\n        scope,\n        /* isAssignment */ true,\n        shouldPreserveCompletion,\n        name => state.addHelper(name),\n        objectRestNoSymbols,\n        /* useBuiltIns */ true,\n      )) {\n        assignments.push(assignmentExpression(\"=\", left, right));\n      }\n      // preserve completion record\n      if (shouldPreserveCompletion) {\n        const { left, right } = assignments[0];\n        // If node.right is right and left is an identifier, then the left is an effectively-constant memoised id\n        if (isIdentifier(left) && right === node.right) {\n          if (\n            !isIdentifier(assignments[assignments.length - 1].right, {\n              name: left.name,\n            })\n          ) {\n            // If the last assignment does not end with left, then we push `left` as the completion value\n            assignments.push(cloneNode(left));\n          }\n          // do nothing as `left` is already at the end of assignments\n        } else {\n          const tempId = scope.generateDeclaredUidIdentifier(\"m\");\n          assignments.unshift(\n            assignmentExpression(\"=\", tempId, cloneNode(node.right)),\n          );\n          assignments.push(cloneNode(tempId));\n        }\n      }\n\n      path.replaceWith(sequenceExpression(assignments));\n      scope.crawl();\n    },\n  };\n\n  const visitor: Visitor<PluginPass> = {\n    Class(path, state) {\n      if (!hasPrivateClassElement(path.node.body)) return;\n      path.traverse(privateKeyDestructuringVisitor, state);\n    },\n  };\n\n  return {\n    name: \"proposal-destructuring-private\",\n    inherits: syntaxDestructuringPrivate,\n    visitor: visitor,\n  };\n});\n"],"names":["assignmentExpression","binaryExpression","conditionalExpression","cloneNode","isObjectProperty","isPrivateName","memberExpression","numericLiteral","objectPattern","restElement","variableDeclarator","variableDeclaration","unaryExpression","types","buildUndefinedNode","transformAssignmentPattern","initializer","tempId","initRestExcludingKeys","pattern","type","properties","length","growRestExcludingKeys","excludingKeys","scope","property","propertyKey","key","computed","isStatic","generateDeclaredUidIdentifier","push","buildVariableDeclarationFromParams","params","elements","transformed","buildAssignmentsFromPatternList","map","left","right","isAssignment","newElements","element","generateUidIdentifier","id","argument","traversePattern","root","visitor","stack","node","index","depth","item","pop","undefined","value","list","i","Error","hasPrivateKeys","result","next","hasPrivateClassElement","body","some","privateKeyPathIterator","indexPath","slice","rightWillBeReferencedOnce","transformPrivateKeyDestructuring","shouldPreserveCompletion","addHelper","objectRestNoSymbols","useBuiltIns","rootRight","restExcludingKeys","searchPrivateKey","done","buildObjectExcludingKeys","indexPathIndex","isRightSafeToReuse","propertiesSlice","nextRestExcludingKeys","leftElements","leftElementsAfterIndex","splice","declare","assertVersion","assumption","t","assignmentPattern","expressionStatement","isExpressionStatement","isIdentifier","isSequenceExpression","sequenceExpression","ignoreFunctionLength","privateKeyDestructuringVisitor","Function","path","firstPrivateIndex","findIndex","param","convertFunctionParams","firstAssignmentPatternIndex","paramsAfterIndex","transformedParams","get","unshiftContainer","crawl","CatchClause","ref","ForXStatement","leftPath","isVariableDeclaration","declarations","temp","kind","init","unshiftForXStatementBody","isPattern","assignExpr","VariableDeclaration","state","declarator","newDeclarations","name","AssignmentExpression","parent","assignments","isCompletionRecord","unshift","replaceWith","Class","traverse","inherits","syntaxDestructuringPrivate"],"mappings":"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"}