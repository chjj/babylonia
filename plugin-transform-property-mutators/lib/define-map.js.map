{"version":3,"names":["_core","require","pushAccessor","mutatorMap","node","_mutatorMap$alias","alias","t","toKeyAlias","map","_inherits","_key","key","push","value","functionExpression","params","body","generator","async","returnType","inheritsComments","kind","toDefineObject","objExpr","objectExpression","Object","keys","forEach","mutatorMapKey","configurable","booleanLiteral","enumerable","mapNode","propNode","objectProperty","_computed","prop","identifier","removeComments","properties"],"sources":["../src/define-map.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\n\ntype DefineMap = {\n  _inherits: t.Node[];\n  _key: t.Expression;\n  get?: t.Expression;\n  set?: t.Expression;\n  kind: \"get\" | \"set\";\n};\n\nexport type MutatorMap = Record<string, DefineMap>;\n\nexport function pushAccessor(\n  mutatorMap: MutatorMap,\n  node: t.ObjectMethod & { kind: \"get\" | \"set\"; computed: false },\n) {\n  const alias = t.toKeyAlias(node);\n  const map = (mutatorMap[alias] ??= {\n    _inherits: [],\n    _key: node.key,\n  } as DefineMap);\n\n  map._inherits.push(node);\n\n  const value = t.functionExpression(\n    null,\n    node.params,\n    node.body,\n    node.generator,\n    node.async,\n  );\n  value.returnType = node.returnType;\n  t.inheritsComments(value, node);\n  map[node.kind] = value;\n\n  return map;\n}\n\nexport function toDefineObject(mutatorMap: any) {\n  const objExpr = t.objectExpression([]);\n\n  Object.keys(mutatorMap).forEach(function (mutatorMapKey) {\n    const map = mutatorMap[mutatorMapKey];\n    map.configurable = t.booleanLiteral(true);\n    map.enumerable = t.booleanLiteral(true);\n\n    const mapNode = t.objectExpression([]);\n\n    const propNode = t.objectProperty(map._key, mapNode, map._computed);\n\n    Object.keys(map).forEach(function (key) {\n      const node = map[key];\n      if (key[0] === \"_\") return;\n\n      const prop = t.objectProperty(t.identifier(key), node);\n      t.inheritsComments(prop, node);\n      t.removeComments(node);\n\n      mapNode.properties.push(prop);\n    });\n\n    objExpr.properties.push(propNode);\n  });\n\n  return objExpr;\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAYO,SAASC,YAAYA,CAC1BC,UAAsB,EACtBC,IAA+D,EAC/D;EAAA,IAAAC,iBAAA;EACA,MAAMC,KAAK,GAAGC,WAAC,CAACC,UAAU,CAACJ,IAAI,CAAC;EAChC,MAAMK,GAAG,IAAAJ,iBAAA,GAAIF,UAAU,CAACG,KAAK,CAAC,YAAAD,iBAAA,GAAjBF,UAAU,CAACG,KAAK,CAAC,GAAK;IACjCI,SAAS,EAAE,EAAE;IACbC,IAAI,EAAEP,IAAI,CAACQ;EACb,CAAe;EAEfH,GAAG,CAACC,SAAS,CAACG,IAAI,CAACT,IAAI,CAAC;EAExB,MAAMU,KAAK,GAAGP,WAAC,CAACQ,kBAAkB,CAChC,IAAI,EACJX,IAAI,CAACY,MAAM,EACXZ,IAAI,CAACa,IAAI,EACTb,IAAI,CAACc,SAAS,EACdd,IAAI,CAACe,KACP,CAAC;EACDL,KAAK,CAACM,UAAU,GAAGhB,IAAI,CAACgB,UAAU;EAClCb,WAAC,CAACc,gBAAgB,CAACP,KAAK,EAAEV,IAAI,CAAC;EAC/BK,GAAG,CAACL,IAAI,CAACkB,IAAI,CAAC,GAAGR,KAAK;EAEtB,OAAOL,GAAG;AACZ;AAEO,SAASc,cAAcA,CAACpB,UAAe,EAAE;EAC9C,MAAMqB,OAAO,GAAGjB,WAAC,CAACkB,gBAAgB,CAAC,EAAE,CAAC;EAEtCC,MAAM,CAACC,IAAI,CAACxB,UAAU,CAAC,CAACyB,OAAO,CAAC,UAAUC,aAAa,EAAE;IACvD,MAAMpB,GAAG,GAAGN,UAAU,CAAC0B,aAAa,CAAC;IACrCpB,GAAG,CAACqB,YAAY,GAAGvB,WAAC,CAACwB,cAAc,CAAC,IAAI,CAAC;IACzCtB,GAAG,CAACuB,UAAU,GAAGzB,WAAC,CAACwB,cAAc,CAAC,IAAI,CAAC;IAEvC,MAAME,OAAO,GAAG1B,WAAC,CAACkB,gBAAgB,CAAC,EAAE,CAAC;IAEtC,MAAMS,QAAQ,GAAG3B,WAAC,CAAC4B,cAAc,CAAC1B,GAAG,CAACE,IAAI,EAAEsB,OAAO,EAAExB,GAAG,CAAC2B,SAAS,CAAC;IAEnEV,MAAM,CAACC,IAAI,CAAClB,GAAG,CAAC,CAACmB,OAAO,CAAC,UAAUhB,GAAG,EAAE;MACtC,MAAMR,IAAI,GAAGK,GAAG,CAACG,GAAG,CAAC;MACrB,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAEpB,MAAMyB,IAAI,GAAG9B,WAAC,CAAC4B,cAAc,CAAC5B,WAAC,CAAC+B,UAAU,CAAC1B,GAAG,CAAC,EAAER,IAAI,CAAC;MACtDG,WAAC,CAACc,gBAAgB,CAACgB,IAAI,EAAEjC,IAAI,CAAC;MAC9BG,WAAC,CAACgC,cAAc,CAACnC,IAAI,CAAC;MAEtB6B,OAAO,CAACO,UAAU,CAAC3B,IAAI,CAACwB,IAAI,CAAC;IAC/B,CAAC,CAAC;IAEFb,OAAO,CAACgB,UAAU,CAAC3B,IAAI,CAACqB,QAAQ,CAAC;EACnC,CAAC,CAAC;EAEF,OAAOV,OAAO;AAChB"}