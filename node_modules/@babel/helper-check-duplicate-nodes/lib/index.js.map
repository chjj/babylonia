{"version":3,"names":["_t","require","VISITOR_KEYS","checkDuplicateNodes","ast","arguments","length","Error","parentsMap","Map","hidePrivateProperties","key","val","stack","node","parent","item","pop","undefined","keys","type","has","parents","get","JSON","stringify","set","subNode","Array","isArray","child","push"],"sources":["../src/index.ts"],"sourcesContent":["import { VISITOR_KEYS } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype StackItem = {\n  node: t.Node;\n  parent: t.Node | null;\n};\nexport default function checkDuplicateNodes(ast: t.Node) {\n  if (arguments.length !== 1) {\n    throw new Error(\"checkDuplicateNodes accepts only one argument: ast\");\n  }\n  // A Map from node to its parent\n  const parentsMap = new Map();\n\n  const hidePrivateProperties = (key: string, val: unknown) => {\n    // Hides properties like _shadowedFunctionLiteral,\n    // which makes the AST circular\n    if (key[0] === \"_\") return \"[Private]\";\n    return val;\n  };\n\n  const stack: StackItem[] = [{ node: ast, parent: null }];\n  let item;\n\n  while ((item = stack.pop()) !== undefined) {\n    const { node, parent } = item;\n    if (!node) continue;\n\n    const keys = VISITOR_KEYS[node.type];\n    if (!keys) continue;\n\n    if (parentsMap.has(node)) {\n      const parents = [parentsMap.get(node), parent];\n      throw new Error(\n        \"Do not reuse nodes. Use `t.cloneNode` (or `t.clone`/`t.cloneDeep` if using babel@6) to copy them.\\n\" +\n          JSON.stringify(node, hidePrivateProperties, 2) +\n          \"\\nParent:\\n\" +\n          JSON.stringify(parents, hidePrivateProperties, 2),\n      );\n    }\n    parentsMap.set(node, parent);\n\n    for (const key of keys) {\n      const subNode =\n        // @ts-expect-error visitor keys must present in node\n        node[key];\n\n      if (Array.isArray(subNode)) {\n        for (const child of subNode) {\n          stack.push({ node: child, parent: node });\n        }\n      } else if (typeof subNode === \"object\" && subNode !== null) {\n        stack.push({ node: subNode, parent: node });\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAA4C;EAAnCC;AAAY,IAAAF,EAAA;AAON,SAASG,mBAAmBA,CAACC,GAAW,EAAE;EACvD,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;EACvE;EAEA,MAAMC,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;EAE5B,MAAMC,qBAAqB,GAAGA,CAACC,GAAW,EAAEC,GAAY,KAAK;IAG3D,IAAID,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,OAAO,WAAW;IACtC,OAAOC,GAAG;EACZ,CAAC;EAED,MAAMC,KAAkB,GAAG,CAAC;IAAEC,IAAI,EAAEV,GAAG;IAAEW,MAAM,EAAE;EAAK,CAAC,CAAC;EACxD,IAAIC,IAAI;EAER,OAAO,CAACA,IAAI,GAAGH,KAAK,CAACI,GAAG,CAAC,CAAC,MAAMC,SAAS,EAAE;IACzC,MAAM;MAAEJ,IAAI;MAAEC;IAAO,CAAC,GAAGC,IAAI;IAC7B,IAAI,CAACF,IAAI,EAAE;IAEX,MAAMK,IAAI,GAAGjB,YAAY,CAACY,IAAI,CAACM,IAAI,CAAC;IACpC,IAAI,CAACD,IAAI,EAAE;IAEX,IAAIX,UAAU,CAACa,GAAG,CAACP,IAAI,CAAC,EAAE;MACxB,MAAMQ,OAAO,GAAG,CAACd,UAAU,CAACe,GAAG,CAACT,IAAI,CAAC,EAAEC,MAAM,CAAC;MAC9C,MAAM,IAAIR,KAAK,CACb,qGAAqG,GACnGiB,IAAI,CAACC,SAAS,CAACX,IAAI,EAAEJ,qBAAqB,EAAE,CAAC,CAAC,GAC9C,aAAa,GACbc,IAAI,CAACC,SAAS,CAACH,OAAO,EAAEZ,qBAAqB,EAAE,CAAC,CACpD,CAAC;IACH;IACAF,UAAU,CAACkB,GAAG,CAACZ,IAAI,EAAEC,MAAM,CAAC;IAE5B,KAAK,MAAMJ,GAAG,IAAIQ,IAAI,EAAE;MACtB,MAAMQ,OAAO,GAEXb,IAAI,CAACH,GAAG,CAAC;MAEX,IAAIiB,KAAK,CAACC,OAAO,CAACF,OAAO,CAAC,EAAE;QAC1B,KAAK,MAAMG,KAAK,IAAIH,OAAO,EAAE;UAC3Bd,KAAK,CAACkB,IAAI,CAAC;YAAEjB,IAAI,EAAEgB,KAAK;YAAEf,MAAM,EAAED;UAAK,CAAC,CAAC;QAC3C;MACF,CAAC,MAAM,IAAI,OAAOa,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;QAC1Dd,KAAK,CAACkB,IAAI,CAAC;UAAEjB,IAAI,EAAEa,OAAO;UAAEZ,MAAM,EAAED;QAAK,CAAC,CAAC;MAC7C;IACF;EACF;AACF"}